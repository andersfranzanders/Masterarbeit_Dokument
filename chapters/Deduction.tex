\chapter{Automatisierte Schmerzbewertung anhand von Schreigeräuschen}
\label{sec:deduction}

In dem vergangenen \autoref{sec:vad} wurden Methoden zur automatisierten Detektion von Schreigeräuschen in Audiosignalen vorgestellt. Dabei wurde erläutert, wie detektierte Schreigeräusche zu Schreieinheiten zusammengefasst werden. Das Ziel dieses Kapitels ist die Vorstellung von Konzepten, um auf Basis der Schreieinheiten die Schmerzbewertung durchzuführen. 

Die Schmerzbewertung des Weinens erfolgt typischerweise nicht aus der Beurteilung einer einzelnen Schreieinheiten, sondern aus der Beurteilung einer Menge mehrerer Schreieinheiten innerhalb eines Beobachtungszeitraumes. Daher ist es zunächst notwendig, erkannte Schreieinheiten so zu gruppieren, das sie gemeinsam einer Schmerzepisode zugeordnet werden können. Diese \emph{Segmentierung} wird in \autoref{sec:segmenting} vorgestellt. Die Möglichkeiten zur Berechnung von Schmerz-Scores anhand objektiv messbarer Eigenschaften des Weinens werden in \autoref{sec:overviewPainRegression} diskutiert.

\section{Zusammenfassung von Schreigeräuschen zu Segmenten}
\label{sec:segmenting}

%Nochemal lesen!
Wie in \autoref{sec:painScores} erläutert wurde, wird die manuelle Schmerzdiagnose bei einem stetigen Monitoring typischerweise umgesetzt, indem Visiten in einer bestimmten Frequenz durchgeführt werden und das Baby bei jeder Visite für einen festgelegten Zeitraum beobachtet wird. Bei jeder Visite werden die Scores für die einzelnen Schmerzindikatoren festgelegt und letztendlich der Schmerzgrad für den jeweiligen Diagnosezeitpunkt bestimmt. So empfiehlt die Schmerz-Scale PAT, das Baby alle 30 Minuten zu überprüfen und jeweils für 15 bis 30 Sekunden zu beobachten. Einige Schmerz-Scales geben keine Empfehlungen für die Beobachtungshäufigkeit und den Beobachtungszeitraum. 

Auch bei einer kontinuierlichen Überwachung durch ein automatisiertes System stellt sich die Frage, zu welchen Zeitpunkten Schmerz-Scores berechnet werden, und welcher beobachtete Zeitraum (\glqq Fenstergröße\grqq ) die Basis der jeweiligen Schmerzbewertung bildet. Es werden zwei Strategien vorgeschlagen:
\begin{enumerate}
\item \textbf{Schmerzdiagnose mit statischen Fenstergrößen: } Es werden feste Werte für die Diagnosefrequenz und den Beobachtungszeitraum festgelegt, ähnlich wie bei der manuellen Schmerzdiagnostik mit Schmerz-Scales. Um die Vorteile eines automatisierten und kontinuierlichen Systems zu nutzen, ist es sinnvoll, die Diagnosefrequenz mit einer weitaus größeren Häufigkeit festzulegen, als es bei der manuellen Überwachung üblich ist. So könnte man beispielsweise alle 2 Sekunden einen Score auf Basis der Informationen der letzten 5 Minuten berechnen. (Diagnosefrequenz $ = \SI{2}{\second}$, Fenstergröße = Beobachtungszeitraum = \SI{5}{\minute}). Diese Strategie ähnelt der, die in dem von Cohen et al. \cite{cohenCry} entwickelten System zur kontinuierlichen Überwachung Neugeborener implementiert wurde (siehe Literaturüberblick in \autoref{sec:system_literature})
\item \textbf{Schmerzdiagnose mit dynamischen Fenstergrößen: } Es wird keine Diagnosefrequenz und kein fester Beobachtungszeitraum festgelegt. Eine Diagnose ruht, solange das Baby keinerlei Anzeichen von Schmerz zeigt. Eine Diagnose wird dann gestartet, sobald das Baby beginnt, potentielle Anzeichen von Schmerz zu zeigen. Wenn das Baby wieder aufhört, potentielle Anzeichen von Schmerz zu zeigen, wird der Schmerz-Score berechnet und die Diagnose beendet. Im Idealfall entspricht ein Diagnosezeitraum einer Schmerzepisode.
\end{enumerate}

Es wurde sich in dieser Arbeit für die zweite Strategie entschieden. Die Begründung ist, dass von den in \autoref{tab:painscores} vorgestellten Schmerz-Scales einige die \emph{Länge des Weinens} als Eigenschaft zur Bestimmung der Schmerzstärke verwenden und somit die Länge der Schmerzepisode selber ein wichtiges Kriterium darstellen kann. Die Verwendung von festen Fensterlängen würde die Bestimmung der genauen Anfangs- und Endzeitpunkte von Schmerzepisoden erschweren.  

Die Berechnung des Schmerz-Score wird zunächst auf das Scoring des Schmerzindikators \emph{Weinen} auf Basis der akustischen Informationen des Audiosignals beschränkt. Unter dieser Einschränkung entspricht ein \glqq potentielles Anzeichen von Schmerz\grqq{} dem \emph{prinzipiellen Vorhandensein von Weingeräuschen}. Aus der Abwesenheit von Weingeräuschen wird zumindest in Bezug auf diesen Schmerzindikator die Abwesenheit von Schmerz geschlossen. Die Ansicht stützt sich auf die Bewertung des Weinens der in \autoref{tab:painscores} vorgestellten Schmerz-Scales, bei denen der überwiegende Teil einen Score von 0 für \glqq kein Weinen\grqq{} vergibt.

%Es ist nicht sinnvoll, dieses Prinzip der Schmerzdiagnose zu festgelegten Visiteintervallen für ein automatisiertes und kontinuierliches System zu übernehmen, da es den Vorteil der Kontinuierlichkeit eliminieren würde.
%Die Frage ist somit, wie eine medizinische Fachkraft das Aufkommen von Schmerz registrieren und den Anfangszeitpunkt der jeweiligen Schmerzdiagnose festlegen würde, würde es das entsprechende Baby kontinuierlich überwachen. Dabei muss bedacht werden, dass eine solche medizinische Fachkraft, so wie das in dieser Arbeit entworfene Systemkonzept, nur die akustischen Informationen zur Verfügung hätte. Die nächst liegende Antwort ist, die Schmerzdiagnose genau dann zu starten, wenn das Baby anfängt, zu weinen. So lange das Baby nicht weint, kann zumindest in Bezug auf diesen Schmerzindikator davon ausgegangen werden, dass kein Schmerz vorliegt (siehe Kapitel \ref{sec:medicalFoundations}).

%Die nächste Frage ist, zu welchem Zeitpunkt die Schmerzdiagnose für die jeweilige Schmerzepisode wieder beendet und ein Schmerz-Score festlegt wird. Da einige Schmerz-Scales aus Tabelle \ref{tab:painscores} Beobachtungszeiträume vorgeben, kann argumentiert werden, dass ein Schmerz-Score direkt nach Beendigung des jeweils angegebenen Beobachtungszeitraums festgelegt werden kann, auch, wenn das Baby weiterhin schreit. Problematisch wären in diesem Fall die Schmerz-Scales, die keine Beobachtungszeiträume vorgeben. Fraglich ist weiterhin, ob eine Vorzeitige Beendigung der Schmerzdiagnose überhaupt sinnvoll ist, wenn ein automatisiertes System zur ständigen Überwachung genau eines Babys vorgesehen ist. Was wäre also der späteste, sinnvolle Zeitpunkt, um nach dem Beginn einer Schmerzepisode einen Schmerz-Score festzulegen und die Diagnose zu beenden? Die nächst liegende Antwort ist: Dann, wenn das Baby wieder aufhört, zu weinen.

Auf Basis dieser Überlegungen wurde das folgende Vorgehen zur kontinuierlichen Segmentierung des Audiosignals entwickelt. Schreieinheiten, die zu einer Schmerzepisode gehören, sollen zu einem \emph{Schrei-Segment} gruppiert werden. So lange das Baby keine Äußerungen von sich gibt, weil es beispielsweise schläft, wird keine Schreieinheit in dem Audiosignal festgestellt, womit für diesen Zeitbereich auch kein Segment existiert. Fängt das Baby an, einen Laut von sich zu geben, welcher vom System als Schreieinheit detektiert wird, wird ein neues Segment eröffnet und die Schreieinheit diesem Segment hinzugefügt. Weitere Schreieinheiten werden so lange diesem Segment hinzugefügt, wie die Dauer der Stille nach einer Schreieinheit einen festgelegten Grenzwert $t_{s}$ nicht überschreitet. Ein Schrei-Segment wird dann geschlossen, wenn das Baby für einen festgelegten Zeitraum keine Laute mehr von sich gibt, also \glqq aufhört, zu weinen\grqq{}. Das Endzeitpunkt des Segmentes wird als der Endzeitpunkt der letzten Schreieinheit des Segmentes festgelegt.

\autoref{eq:cry-segment} definiert ein \emph{Schrei-Segment} (engl. \emph{Cry-Segment}) [$CS$] als Liste, die Schreieinheiten beinhaltet. Die Indexierung eines Schreisegmentes beginnt bei $0$. Ein Schreisegment beinhaltet $N$ Schreieinheiten. Der Index der letzten Schreieinheit eines Segments ist somit $N-1$. Schrei-Segmente werden in dieser Arbeit auch kurz nur als \emph{Segment} bezeichnet.

\begin{equation}
CS = [cu_0 ,  \ldots,  cu_{N-1}]
\label{eq:cry-segment}
\end{equation}

Alle Schreieinheiten eines Schrei-Segments erfüllen die Nebenbedingung aus \autoref{eq:cry-segment-nb}, das heißt, dass die Distanzen aller benachbarter Schreieinheiten eines Segments unterhalb des Grenzwertes $t_{s}$ liegen.


\begin{equation}
\forall cs \in CS: \forall i = 0 , \ldots , N-2 : d(cs[i], cs[i+1]) < t_{s}
\label{eq:cry-segment-nb}
\end{equation}

Der Startzeitpunkt eines Schrei-Segments wird nach \autoref{eq:cry-segment-start} als der Startzeitpunkt der ersten Schreieinheit des Segments definiert. Der Endzeitpunkt eines Segmentes wird definiert als der Endzeitpunkt der letzten Schreieinheit des Segments nach \autoref{eq:cry-segment-end}.

\begin{equation}
start(cs) = cs[0].start
\label{eq:cry-segment-start}
\end{equation}

\begin{equation}
end(cs) = cs[N-1].end
\label{eq:cry-segment-end}
\end{equation}

Algorithmus \ref{alg:crySegment} zeigt einen Pseudocode zur Offline-Segmentierung nach dem vorgestellten Prinzip. Input des Algorithmus ist eine Liste aller Schreieinheiten $CU_{all}$, die nach dem Decision-Smoothing nach Algorithmus \ref{alg:decisionSmoothing} entstanden ist. Der Output des Algorithmus ist eine Liste $CS_{all}$, die alle gefundene Schreisegmente  $[cs_0 , \ldots ,  cs_n]$ enthält. \autoref{img:segmenting06} zeigt eine nach diesem Prinzip durchgeführte Segmentierung anhand eines Beispiels.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{bilder/segmentierung08.png}
	\caption[Beispiel für eine Segmentierung]{Beispiel für eine Segmentierung mit einem Grenzwert von $t_s = \SI{6}{\second}$}
	\label{img:segmenting06}
\end{figure}

Der Algorithmus eignet sich nicht für eine Online-Segmentierung, da das Ende eines Segmentes erst bei Beginn eines neuen Segmentes festgestellt wird, wobei beliebig viel Zeit zwischen den benachbarten Segmenten liegen kann. Wurde beispielsweise $t_{s} = \SI{1}{\minute}$ festgelegt, und die Pause zwischen zwei benachbarten Segmenten beträgt eine Stunde, so wäre das Ende des ersten Segmentes 59 Minuten zu spät festgestellt worden. Bei einer online durchgeführten Segmentierung empfiehlt es sich, die Dauer der Stille nach jeder neu erkannten Schreieinheit kontinuierlich zu messen und ein Segment sofort zu beenden, wenn ein Stillezeitraum den Grenzwert $t_s$ überschreitet.

\begin{algorithm}[h]
	\caption{Gruppierung von Schreieinheiten zu Schrei-Segmenten}
	\label{alg:crySegment}
	\begin{algorithmic}[1]
		\Function{segmentCryUnits}{$CU_{all}, t_{s}$}
		\State $ CS_{all} \gets [\;]$
		\State $ cs \gets [CU_{all}[0]]$
				\For{ $i = 1 , \ldots , length(CU_{all}) - 1$}
						\State $ cu_i \gets CU_{all}[i]$
						\State $cu_{i-1} \gets CU_{all}[i-1]$
						\If{d$(cu_{i-1},cu_i) < t_{seg-max}$}
								\State $cs \gets [cs_i , cu_i]$
						\Else
								\State $CS_{all} \gets [CS_{all}, cs]$
								\State $cs \gets [cu_i]$
						\EndIf
				\EndFor
		\Return $CS_{all}$
		
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}


Das hier vorgestellte Segmentierungsverfahren wurde bewusst möglichst einfach gehalten, damit die Bedeutung des Parameters $t_{s}$ leicht ersichtlich ist und somit von der medizinischen Fachkraft selbständig festgelegt werden kann. Das Ende eines Segmentes ist weiterhin ein geeigneter Zeitpunkt, um die Parameter des Kompressors der Vorverarbeitungsstufe auf Basis des RMS-Wertes des Segmentes zu aktualisieren (siehe \autoref{sec:preprocessing}).


\section{Methoden zur Berechnung des Schmerz-Score für Segmente}
\label{sec:overviewPainRegression}

Das Ziel ist nun, nach dem Ende jeder Schmerzepisode einen Schmerz-Score für diese zu berechnen. Wie in Kapitel \ref{sec:medicalFoundations} erläutert wurde, ergibt sich ein Schmerz-Score aus der Summe der Scores, die für die einzelnen Schmerzindikatoren vergeben wurden. Auf Basis des akustischen Signals wird der Score des Schmerzindikators \emph{Weinen} berechnet. Betrachtet man allein diesen Schmerzindikator, so entspricht eine Schmerzepisode einem Schrei-Segment, wie im vergangenen Unterabschnitt argumentiert wurde.

Das nächste Teilproblem ist somit, \emph{Hypothesen} (auch: \emph{Modelle}, siehe \autoref{sec:learning}) zu finden, die für Schreisegmente Scores berechnen. Eine Hypothese ist abhängig von der jeweiligen Schmerz-Scale, da verschiedene Schmerz-Scales unterschiedliche Scorings definieren. Mathematisch formalisiert ist eine solche Hypothese $P_{Scale}$ eine von der jeweiligen Schmerz-\emph{Scale} abhängige Funktion, die ein Schreisegment $cs \in CS$ auf einen von der Schmerz-Scale abhängigen \emph{Score} $s \in S_{Scale}$ abbildet, da heißt $P_{Scale}: CS \mapsto S_{Scale}$.

Angenommen, es soll die Schmerz-Scale \emph{NIPS} aus \autoref{tab:nips} zur Schmerzbewertung verwendet werden. In Bezug auf den Schmerzindikator \emph{Weinen} wird ein Score von 0 vergeben, wenn kein Weinen vorliegt, ein Score von 1, wenn das Weinen als \glqq mumbling\grqq{} (murmelnd) bewertet wird und ein Score von 2, wenn das Weinen als \glqq vigorous\grqq{} (energisch) bewertet wird. Formuliert als Modell $P_{NIPS}:CS \mapsto \{0, 1 , 2\}$ ergibt sich:

\begin{equation}
P_{NIPS}(cs) = \begin{cases}
 2 \quad ,\text{wenn } cs \text{ \glqq energisch ist\grqq } \\
 1 \quad ,\text{wenn } cs \text{ \glqq murmelnd ist\grqq } \\
 0 \quad ,\text{wenn } cs \text{ \glqq kein Weinen ist\grqq }
 \end{cases}	
\end{equation}

Das Problem ist offensichtlich: \glqq murmelnd\grqq{} und \glqq energisch\grqq{} sind subjektiv behaftete Begriffe und lassen sich nicht ohne weiteres aus den Eigenschaften eines Segmentes feststellen. Es muss somit für jede Schmerz-Scale eine Hypothese konstruiert werden, welches den Score für ein Schrei-Segment anhand \emph{objektiv messbarer Signaleigenschaften} berechnet. 

Die folgende Strategie wird vorgeschlagen, um für eine beliebige Schmerz-Scale eine solche Hypothese $P_{Scale}$ zu gewinnen:

\begin{enumerate}
 \item Man erstellt eine Datenbank mit Audioaufnahmen mit dem Weinen von Babys. Jede Audioaufnahme wird so beschnitten, dass sie eine Scherzepisode / ein Schrei-Segment enthält.
 \item Man errechnet für jede Audioaufnahme \glqq so viele \emph{objektiv} messbare Eigenschaften wie möglich\grqq{}, wie zum Beispiel die insgesamt Segment-Länge, die durchschnittliche Länge der enthaltenen Schreieinheiten, durchschnittliche Tonhöhe usw.
 \item Man bittet medizinische Fachkräfte, für jede Aufnahme der Datenbank einen Score auf Basis der Kriterien der jeweiligen Schmerz-Scale zu vergeben, für die man eine Hypothese sucht. So erhält man einen gelabelte Trainingsdatensatz.
 \item Man trainiert einen \emph{Algorithmus zur ordinalen Regression} mit diesem Datensatz, um den Zusammenhang zwischen den in Schritt 2 objektiv gemessenen Eigenschaften der Schreisegmente und den in Schritt 3 vergebenen Scores herzustellen (siehe \autoref{sec:learning}). Es wird darauf hingewiesen, dass es sich hierbei \emph{nicht} um ein herkömmliches Regressionsproblem handelt, da die Schmerz-Scales Ordinalskalen, und keine kontinuierlichen Skalen definieren. In diesem Arbeitsschritt wird sich herausstellen, welche der Segment-Eigenschaften mit der Höhe des Scores korrelieren und zur Prognose sinnvoll sind. Das Ergebnis dieses Schrittes ist eine Hypothese $P_{Scale}$.
\end{enumerate}

Eine Hypothese $P_{Scale}$ kann daraufhin in dem automatisierten System eingesetzt werden, um für neue, bisher unbekannte Schrei-Segmente den Score für das Weinen zu prognostizieren. Der Vorteil dieser Vorgehensweise zur Erstellung der Hypothesen ist, dass das Problem der Übersetzung der objektiv messbaren Signaleigenschaften in die subjektiv behafteten Begriffe, die von den Schmerz-Scales verwendet werden, überbrückt wird, indem man die Regression direkt von den Signaleigenschaften auf den Score durchführt. Der Nachteil dieser Strategie ist, dass für jede Schmerz-Scale eine gesonderte Hypothese konstruiert werden muss, auch, wenn zwei Schmerz-Scales den selben subjektiv behafteten Begriff verwenden.

Dieser Vorschlag ist nur eines von mehreren denkbaren Vorgehen zur Gewinnung von Hypothesen für Schmerz-Scales. So könnte beispielsweise Anstatt der ordinalen Regression von den Segmenteigenschaften auf den Score eine Klassifizierung auf die subjektiv behafteten Begriffe durchgeführt werden, und diese daraufhin zur Berechnung des Scores zu verwenden. Es ist im zeitlichen Rahmen dieser Arbeit nicht möglich gewesen, selber Hypothesen für Schmerz-Scales nach dem vorgestellten Vorgehen zu erstellen. Die Akquise von Audioaufnahmen von Babys sowie die Schmerzbewertung dieser in Zusammenarbeit mit medizinischen Fachkräften erfordern nicht nur Zeit, sondern das Fachwissen über das Führen und die Auswerten von Interviews.

In den folgenden Teilabschnitte werden zwei Teilprobleme der Schmerzbewertung genauer beleuchtet. \autoref{sec:segmentFeatures} erläutert die Berechnung objektiv messbarer Eigenschaften für Schrei-Segmente, auf die sich die Hypothesen stützen können. In \autoref{sec:regressionTimeStuff} werden Möglichkeiten vorgestellt, um den Verlauf des Schmerzgrades innerhalb von Schrei-Segmenten auszuwerten.


%\vspace{5mm}

%\textbf{Strategie 1} \noindent\rule{0.83\linewidth}{0.3pt}\\
%... löst das Problem mit Hilfe von \emph{ordinaler Regression auf die Scores} (Siehe Abschnitt \ref{sec:learning}):
%\begin{enumerate}
 %\item Man erstellt eine Datenbank mit Aufnahmen von kindlichen Lautäußerungen, die man segmentiert.
 %\item Man errechnet \glqq so viele \emph{objektiv} messabare Eigenschaften wie möglich\grqq{} für jedes Segment, wie zum Beispiel die insgesamte Länge, die durchschnittliche Länge der enthaltenen Cry-Units, durchschnittliche Tonhöhe usw.
 %\item Man bittet medizinische Fachkräfte, für jedes Segment der Datenbank einen Score bezüglich der Schmerz-Scale zu vergeben, für den man den Predictor sucht. So erhält man einen gelabelte Trainingsdatensatz 
 %\item Man trainiert einen \emph{Algorithmus zur ordinalen Regression} mit diesem Datensatz, um den Zusammenhang zwischen den in Schritt 2 objektiv gemessenen Eigenschaften der Segmente und den in Schritt 3 vergebenen Scores herzustellen. Es wird darauf hingewiesen, dass es sich hierbei \emph{nicht} um ein herkömmliches Regressionsproblem handelt, da die Scales Ordinalskalen, und keine kontinuierlichen Skalen definieren. Man erhält somit einen Prediktor für jede Schmerz-Scale.
 %\item Möchte man für neue, unbekannte Segmente den Score bezüglich des Weinens prognostizieren, nutzt man den entsprechenden Regressor.
%\end{enumerate}
%\noindent\rule{\linewidth}{0.3pt}

%Das Vorteil dieses Vorgehens ist, dass das Problem der Übersetzung der objektiv messbaren Segmenteigenschaften in die subjektiv behafteten Begriffe, die in den Schmerz-Scales zum Scoring verwendet werden, überbrückt wird. Der Score wird direkt aus den objektiv messbaren Eigenschaften eines Segmentes berechnet. Der Nachteil ist, dass das Labeling zum Aufbau des Trainingsdatensatzes für jede Pain-Scale aufgebaut werden muss. Wird ein neue Pain-Scale eingeführt, muss der Prädiktor für diese Scale durch erneutes Labeln festgestellt werden. Ein weiterer Effekt der Abbildung des Problems als Regression ist, dass ein Regressor in einen kontinuierlichen Zahlenraum abbildet. Es sind also Regressionsergebnisse wie zum Beispiel $2.8$ denkbar. Diese \glqq bessere Auflösung\grqq{} kann als Vorteil betrachtet werden. Ist jedoch eine direkte Übersetzung der Pain Scale inklusive der ganzzahligen Punktzahlen gewünscht, so stellt sich die Frage, ob eine $2.8$ auf- oder abzurunden ist.

%\vspace{5mm}

%\textbf{Strategie 2} \noindent\rule{0.83\linewidth}{0.3pt} \\
%... löst das Problem mit Hilfe von Klassifizierung (Siehe Kapitel \ref{sec:classification}):
%\begin{enumerate}
%	\item und 2. entsprechen Strategie 1
%	\stepcounter{enumi}
%	\item Man sammelt alle subjektiven Begriffe, die in Pain Scales verwendet werden, wie zum Beispiel \glqq murmelnd\grqq , \glqq energisch\grqq , usw.
%	\item Man bittet medizinische Fachkräfte, jedes Segment der Datenbank mit denjenigen Begriffen zu labeln, die die jeweilige Person für zutreffend hält. 
%	\item  Man Verwendet einen \emph{Klassifizierungsgorithmus}, um einen Zusammenhang zwischen den in Schritt 2 festgestellten objektiv messbaren Eigenschaften der Segmente und den \emph{subjektiv behafteten Begriffen} zu finden. Man erhält somit einen Klassifikator für jeden Begriff, der binär in \emph{positive = zutreffend} und \emph{negative = nicht zutreffend} klassifiziert.
%	\item Möchte man für neue, unbekannte Segmente die Pain Score prognostizieren, so wird für jede mögliche Score der Pain Scale überprüft, ob für alle subjektiv beschreibenden Begriffe der entsprechende Klassifikator ein positive prognostiziert. Die Ableitung der Score ist somit ein weiters Klassifizierungsproblem, wobei eine Score einer Klasse entspricht und genau dann abgeleitet werden kann, wenn alle Vorraussetzungen für die Klasse erfüllt sind.
%\end{enumerate}
%\noindent\rule{\linewidth}{0.3pt}

%Der Vorteil dieser Methode ist, dass auch zum Zeitpunkt der Erstellung der Testdatenbank unbekannte Pain Scales zu einem späteren Zeitpunkt eingebunden werden können, insofern alle in dieser neuen Pain Scale verwendeten subjektiv behafteten Begriffe bereits gelabelt vorliegen, weil sie auch in anderen Pain Scales verwendet wurden. Das Vorgehen erlaubt somit eine gewissen Flexibilität bezüglich zukünftig entwickelter Pain Scales. Der Nachteil dieser Methode ist, dass durch die Umwandlung der eigentlich quantitativ geordenten Score einer Pain Scale in qualitative Klassen aus einem implizit als Regression zu betrachtenden Problem ein Klassifizierungsproblem macht. Dies wirft neue Fragen auf, wie zum Beispiel: Angenommen, bei einer fiktiven Pain Scale wird jede Score mit jeweils drei subjektiv behafteten Begriffen beschrieben, und bei der Klassifizierung eines Segmentes wird festgestellt, dass für jede Punktzahl genau zwei der drei Begriffe erfüllt werden. Welche Score wird dann prognostiziert? Ein anderes Beispiel wird am Beispiel der der NIPS-Score aus Tabelle \ref{tab:nips} verdeutlicht: Angenommen, ein Cry-Segment enthält hörbar \glqq starkes\grqq{} Schreien, es kann jedoch weder \glqq mumbling (murmelnd) \grqq{} noch \glqq vigorous (energisch)\grqq{} abgeleitet werden. Demzufolgen müsste dieses Segment eine Score von 0 Punkten erhalten, wobei ein Mensch in dieser Situation eventuell \glqq stark\grqq{} zu \glqq heftig\grqq{} uminterpretieren und 2 Punkte vergeben hätte. Strategie 1 ist weniger anfällig für dieses Problem.

%In jedem Fall werden medizinische Fachkräfte benötigt, um das Labeling der Cry-Segmente durchzuführen, was aus Zeitgründen im Rahmen dieser Arbeit nicht möglich ist. Die Aquise von Audioaufnahmen von Babys sowie das Labeling der Aufanhmen erfodern nicht nur Zeit, sondern das Fachwissen über das Führen und die Auswerten von Interviews.

\subsection{Extrahierung von Eigenschaften als Grundlage zur Schmerzbewertung}
\label{sec:segmentFeatures}

%Wie im vergangenen Abschnitt erläutert wurde, stützt sich eine Hypothese zur Berechnung eines Score für das Weinen auf objektiv messbare Eigenschaften der Schrei-Segmente. In diesem Kapitel werden Möglichkeiten zur Berechnung dieser Eigenschaften besprochen.

Varallyay \cite[S. 16 - 17]{cry_thesis} hat in seiner Dissertation vorgeschlagen, die Segment-Bezogenen Eigenschaften in drei Klassen einzuteilen: 1.) Eigenschaften des Zeitbereichs, 2.) Eigenschaften der Frequenzbereichs, und 3.) Melodie-bezogene Eigenschaften. Diese Kategorisierung wurde für die Einteilung der Eigenschaften übernommen. In den folgenden Unterabschnitten werden konkrete Eigenschaften definiert und Berechnungsvorschriften festgelegt. Die vorgestellten Eigenschaften orientieren sich an denen, die in \autoref{sec:acousticModel} im Zusammenhang mit der Schreiforschung vorgestellt wurden. Die Berechnungsvorschriften basieren auf den in dieser Arbeit eingeführten Datentypen \emph{Schrei-Segment} aus \autoref{eq:cry-segment} und \emph{Schreieinheit} aus \autoref{eq:cry-Unit}.

Das Ziel dieses Abschnittes ist vor Allem, Möglichkeiten der Analyse der Schrei-Segmente zu demonstrieren. Es handelt sich hierbei nicht um eine vollständige Formalisierung aller in der Literatur genannten Eigenschaften, die zur Prognose von Emotionen, Krankheiten oder Schmerzstärken verwendet wurden. Weiterhin ist es in dieser Arbeit nicht möglich, festzustellen, welche der definierten Eigenschaften sinnvoll für die Prognose von Schmerz-Scores sind, da dies ohne die Erstellung von Hypothesen nicht möglich ist.

%Im vergangenen Kapitel wurde erläutert, dass die Basis für die Ableitung einer Pain Score für ein Segment die Extraktion von \glqq so vielen Features wie möglich\grqq{} ist. In diesem Kapitel wird präzisiert, welche Features gemeint sind.  Varallyay \cite[S. 16 - 17]{cry_thesis} schlug vor, drei Kategorien an Features zu betrachten: 1.) Features des Zeitbereichs, 2.) Features der Frequenzbereichs, und 3.) Melodie-bezogene Attribute. Diese Kategorisierung wurde für diese Arbeit übernommen.

%In Kapitel \ref{sec:acousticModel} wurde beschrieben, welche Features in der medizinischen Schreiforschung typischerweise extrahiert wurden. In Kapitel \ref{sec:cryDiscussion} wurde diskutiert, dass 1.) nicht bewiesen ist, welche Features die \glqq wichtigsten\grqq{} sind und 2.) keine Einigung darüber herrscht, wie genau bestimmte Features zu berechnen sind. Basierend auf den in diesem Kapitel vorgestellten Features werden in diesem Kapitel konkrete Berechnungsvorschriften definiert. Welche von diesen Features tatsächlich im Zusammenhang mit Schmerz stehen, lässt sich erst in der anschließenden Nutzung der Features zur Regression oder Klassifizierung der Pain Scales feststellen, welche jedoch im Rahmen dieser Arbeit nicht durchgeführt werden kann.

\subsubsection{Eigenschaften des Zeitbereiches}

Mit Features des Zeitbereiches sind solche gemeint, die sich allein aus Kenntnis der Start- und Endzeitpunkte der im Segment enthaltenen Schreieinheiten sowie deren Zeitbereiche gewinnen lassen, wie beispielsweise die durchschnittliche Länge der Schreieinheiten oder die durchschnittliche Energie der Schreieinheiten.\cite[S. 16 - 17]{cry_thesis} In diesem Kapitel gilt die Konvention, dass eine Schrei-Segment $cs$ insgesamt $N$ Schreeinheiten enthält, die Indexierung wird mit $0 \ldots N-1$ definiert.

\begin{description}
\item[Segment-Length: ] Die Zeitliche Länge eines Segmentes wird nach \autoref{eq:segment_length} berechnet:
\begin{equation}
\text{S-Length}(cs) = cs[N-1].end - cs[0].start
\label{eq:segment_length}
\end{equation}

\item[Density: ] Der Relativer Anteil der Länge der Schreieinheiten an der Länge des Segmentes wird nach \autoref{eq:segment_density} berechnet. Die Länge einer Schreieinheit wurde in \autoref{eq:cry-Lambda} definiert.
\begin{equation}
\text{Density}(cs) = \frac{\sum_{i = 0}^{N-1} \lambda(cs[i])}{\text{Segment-Length}(cs)}
\label{eq:segment_density}
\end{equation}

\item[Tempo:] Dieses Feature beschreibt das Verhältnis zwischen der Anzahl an Schreieinheiten und der Dauer des Segmentes. Die Eigenschaft ähnelt dem von LaGasse et al. \cite[S. 85]{parentalPerception} als \emph{Utterances} bezeichneten Feature.

\begin{equation}
\text{Tempo}(cs) =  \frac{N}{\text{S-Length}(cs)}
\end{equation}

\item[Statistics of Cry-Units:] Es können statistische Kennwerte bezüglich der \emph{Längen aller Schreieinheiten} eines Schrei-Segmentes berechnet werden. \autoref{eq:featuresOfCryUnits} zeigt, wie der Durchschnitt, Median, Minimum, Maximum sowie die Standardabweichung der Länge der Schreieinheiten berechnet werden. Diese Liste an statistischen Kenngrößen lässt sich beliebig erweitern, beispielsweise durch die Bestimmung von Quartilen. Das $\text{mean}_{cu}(cs)$-Feature wird von LaGasse et al. \cite[S. 85]{parentalPerception} und in weiteren Veröffentlichung als \emph{Mean Duration} bezeichnet. Diese Kenngrößen wurden unter anderem von Zeskind et al. \cite{rythmic} bei der Untersuchung des Weinens Neugeborener berechnet.

\begin{equation}
\begin{gathered}
\text{mean}_{cu}(cs) = \meani_{i = 0 \ldots N-1}\{\lambda(cs[i])\} \\
\text{median}_{cu}(cs) = \mediani_{i = 0 \ldots N-1}\{\lambda(cs[i])\} \\
\text{min}_{cu}(cs) = \mini_{i = 0 \ldots N-1}\{\lambda(cs[i])\} \\
\text{max}_{cu}(cs) = \maxi_{i = 0 \ldots N-1}\{\lambda(cs[i])\} \\
\sigma_{cu}(cs) =  \sigma_{i = 0 \ldots N-1}\{\lambda(cs[i])\} 
\end{gathered}
\label{eq:featuresOfCryUnits}
\end{equation}

\item[Statistics of Bursts:]\footnote{Erläuterung zum Begriff \emph{Burst} in \autoref{sec:acousticModel}} Die in \autoref{eq:featuresOfCryUnits} definierten statistischen Kennwerte können ebenso in Bezug auf die \emph{Längen aller Bursts} eines Segmentes errechnet werden, in dem in jeder Gleichung $\lambda(cs[i])$ ersetzt wird durch $cs[i].start - cs[i-1].start$. Die Indexierung muss auf $i = 1 ,\ldots, N-1$ begrenzt werden. In \autoref{eq:featuresOfBursts} wird nur die Berechnung der durchschnittlichen Länge aller Bursts gezeigt, da die Berechnungsvorschriften weiterer statistischer Kennwerte nach dem Prinzip aus \autoref{eq:featuresOfCryUnits} ersichtlich sind. Diese Kenngrößen wurden ebenfalls von Zeskind et al. \cite{rythmic} in Untersuchungen verwendet.

\begin{equation}
\begin{gathered}
\text{mean}_{burst}(cs) = \meani_{i = 1 \ldots N-1}\{cs[i].start - cs[i-1].start\} \\
\text{median}_{burst}(cs) = \ldots \\
\ldots
\end{gathered}
\label{eq:featuresOfBursts}
\end{equation}

\item[Statistics of Pauses:] Nach dem selben Muster können statistische Kennwerte bezüglich der  \emph{Längen aller Pausen} eines Segmentes ermittelt werden. Eine Pause entspricht in diesem Zusammenhang der Distanz zwischen zwei auf einander folgenden Schreieinheiten nach \autoref{eq:cry-distance}. In \autoref{eq:featuresOfPauses} wird ebenfalls nur die Vorschrift zur Berechnung des Durchschnitts gezeigt.

\begin{equation}
\begin{gathered}
\text{mean}_{pause}(cs) = \meani_{i = 1 \ldots N-1}\{d(cs[i-1],cs[i])\} \\
\ldots
\end{gathered}
\label{eq:featuresOfPauses}
\end{equation}

\item[Statistics of Energies:] Zunächst wird die Liste aller in den Schreieinheiten eines Segmentes enthaltenen Signalfenster definiert nach \autoref{eq:windowsOfSegment}. Eine Schreieinheit enthält die Signalfenster $cu.windows = x_0[\;],\ldots,x_n[\;]$

\begin{equation}
x_{seg}[\; ] = cs[0].windows[0] \;  , \; \ldots \; , \; cs[N-1].windows[n] 
\label{eq:windowsOfSegment}
\end{equation}

Die Liste $x_{seg}[\; ]$ enthält $R$ Signalfenster, die Indexierung wird definiert mit $0, \ldots, R-1$.  \autoref{eq:energyStats} definiert die Berechnung statistischer Kennwerte bezüglich der \glqq Lautstärke Segmentes\grqq. Der MSV-Wert als Maß des durchschnittlichen Energiegehaltes wurde in \autoref{eq:msv} definiert, weitere Kenngrößen können ergänzt werden.

\begin{equation}
\begin{gathered}
\text{mean}_{msv}(cs) = \meani_{i = 0 \ldots R-1}\{MSV(x_{seg}[i])\} \\
\ldots
\end{gathered}
\label{eq:energyStats}
\end{equation}

\end{description}

Es wird angemerkt, dass in der Schreiforschung zeitliche Eigenschaften im geringeren Maße in Betracht gezogen wurden als Features des Frequenz-Bereiches. Die einzigen zeitliche Features, die zum Beispiel von Wasz-Hockert et al. \cite{25years}, Fuller \cite{threeCryTypes} und LaGasse et al. \cite{parentalPerception} berechneten wurden, sind \emph{die durchschnittliche Länge der Schreieinheiten} sowie die \emph{Latenz zwischen Reiz und erster Schreieinheit der Schmerzantwort}. Die durchschnittliche Länge der Schreieinheiten wurde in \autoref{eq:featuresOfCryUnits} definiert.
, welche nur auf Basis des Audiosignals nicht feststellbar ist. Es spricht jedoch nichts dagegen, die hier vorgestellten Features trotzdem zu erproben. Die anschließende Nutzung der Features zur Regression/Klassifizierung wird Auskunft darüber geben, welchen Beitrag diese Features zur Schmerzdiagnose leisten können.

\subsubsection{Eigenschaften des Frequenzbereiches und der Melodie}

Als Grundlage zur Definition von Segmenteigenschaften des Frequenzbereiches werden alle Signalfenster der Schreieinheiten eines Segmentes in den Frequenzbereich transformiert und in der Liste $X_{seg}[\;]$ nach \ref{eq:specOfSegment} gesammelt. Dies entspricht der Kurzzeit-Fourier-Transformation aller Schreieinheiten des Segmentes (siehe \autoref{sec:stft}). Die Indexierung von $X_{seg}[\;]$ läuft, wie bei $x_{seg}$, von $0 , \ldots , R-1$. Analog dazu wird die Liste aller Cepstren der Schreieinheiten eines Segmentes $c_{seg}[\;]$ definiert. 

\begin{equation}
X_{seg}[\; ] = \Big[ |DFT\{x_{seg}[0] \cdot w[\;]\}| \; , \ldots , \; |DFT\{x_{seg}[R-1] \cdot w[\;]\}| \Big]
\label{eq:specOfSegment}
\end{equation}


Die folgenden Eigenschaften des Frequenzbereiches lassen sich mit den in dieser Arbeit vorgestellten Methoden berechnen:

\begin{description}
\item[Ratio2:] Diese Eigenschaft wurde von Fuller \cite{threeCryTypes} definiert und beschreibt die Spannung des Vokaltraktes als Verhältnis der Energien oberhalb von \SI{2000}{\hertz} zu den Energien unter \SI{2000}{\hertz}. Wie bei den Eigenschaften des Zeitbereiches können verschiedene statistische Kennwerte bezüglich dieser Eigenschaft berechnet werden. \autoref{eq:ratio2} zeigt die Berechnung des Durchschnitts.

\begin{equation}
\begin{gathered}
text{mean}_{Ratio2}(cs) = \meani_{i=0\ldots R-1} \Big\{ \frac{\sum_{k=0}^{\SI{2000}{\hertz}} X_{sec}[i][k]^2}{\sum_{j=\SI{2000}{\hertz}}^{f_{s}} X_{sec}[i][j]^2} \Big\} \\
\ldots
\end{gathered}
\label{eq:ratio2}
\end{equation}


\item[Clarity: ] Wie in Kapitel \ref{sec:vad_ceps_features} erläutert wurde, deutet eine klar ausgebildete Spitze im oberen Cepstrum-Bereich auf ein stimmhaftes Signal hin. Ein hoher Anteil hoher Cepstrum-Peaks lässt somit auf vermehrt phonierte Laute schließen, geringere Cepstrum-Peaks auf dysphoniertere Laute (Siehe Kapitel \ref{sec:acousticModel}). Der Durchschnittswert dieser Eigenschaft ist ein Maß für den Relativen Anteil dysphonierter Laute, die Standardabweichung ähnelt dem in Kapitel \ref{sec:acousticModel} vorgestellten \emph{Cry-Mode Changes}-Feature.

\begin{equation}
\begin{gathered}
\text{mean}_{Clarity}(cs) = \meani_{i=0\ldots R-1} \Big\{ Ceps_{mag}(c_{seg}[i])  \Big\} \\
\ldots
\end{gathered}
\end{equation}
	
	
\end{description}

Alle weiteren Eigenschaften, die in Kapitel \ref{sec:acousticModel} vorgestellt wurden und sich auf den Frequenzbereich oder den Melodieverlauf der Schreieinheiten beziehen, lassen sich nicht mit den in dieser Arbeit vorgestellten Methoden berechnen. Zur Definition dieser Eigenschaften sind Methoden zur Bestimmung der Formanten oder der Grundtonhöhe notwendig. Das Muster, nach dem diese Features berechnet werden können, sollte aus den bisher vorgestellten Features ersichtlich sein. 

%Bei allen vorgestellten Eigenschaften handelt es sich, nach dem Vorbild der in Kapitel \ref{sec:acousticModel} vorgestellten Methoden der klassischen Schreiforschung, um solche, bei denen die Reihenfolge der Cry-Units nicht mit in Betracht gezogen wird. Angenommen, ein Segment besteht aus $n$ Cry-Units, wobei genau eine hälfte der  Cry-Units kurz und die andere hälfte der Cry-Units lang ist. Das $\text{stats}_{cu}(cs)$-Feature wird bezüglich des Durchschnittes, Minimum, Maximum etc. die selben Werte berechnen, unabhängig davon, ob sich die kurzen Cry-Units allesamt am Beginn des Segmentes, am Ende des Segmentes oder mit den langen Cry-Units durchmischt befinden. Bei der anschließenden Nutzung der Features zu Regression/Klassifizierung wird sich zeigen, wie sehr sich diese Features zur Ableitung von Pain-Scores eignen. Stellt sich heraus, dass sich die Features nicht eignen, ist es eventuell notwendig, neue Features zu definieren, die die Position der Cry-Units mit in Betracht ziehen.

\subsection{Schmerzverlauf innerhalb von Segmenten}
\label{sec:regressionTimeStuff}

Die Ableitung genau einer Pain Score für ein Cry-Segment stellt den einfachsten Fall dar. Dies ist für bestimmte Anwendungsfälle eventuell nicht ausreichend: 
\begin{enumerate}
\item Die Score kann erst nach der Beendigung eines Segmentes abgeleitet werden, was für einigen Kontexte möglicherweise zu spät ist. Besonders die Schmerzdiagnostik während Schmerzverursachenden Prozeduren kann das häufigere \glqq Aktualisieren\grqq der Schmerzscore notwendig machen.
\item Falls der Schmerz innerhalb eines Segmentes stark ab- oder zunimmt, ist dieser Verlauf nicht erkennbar. Es würde lediglich der \glqq durchschnittliche Schmerz\grqq{} des Segmentes abgeleitet werden.
\end{enumerate}

Das vorgestellte Prinzip wird daher erweitert, indem ein Aktualisierungsintervall $t_{act}$ und Beobachtungszeitraume $t_{obs}$ eingeführt wird.

\subsubsection{Aktualisierungsintervall}
\label{sec:actualization}

 Die Grundlegende Idee des Aktualisierungsintervalls ist, bei einem momentan offenen Segment in regelmäßigen Abständen die Features abzufragen und direkt die Pain Score abzuleiten, um Zwischenergebnisse zu erhalten. Der am häufigsten umsetzbare Fall ist, ein Aktualisierung nach jeder neu dem Segment hinzugefügten Cry-Unit vorzunehmen. Der am wenigsten häufige Fall ist der bereits genannte, die Aktualisierung erst bei Beendigung eines Segmentes durchzuführen. Eine offensichtliche Variante zur Festlegung von $t_{act}$ ist die Bestimmung eines zeitlichen Wertes. Ein $t_{act}$ von beispielsweise \SI{10}{\second} würden bedeuten, dass alle 10 Sekunden ein neuer Pain Score für ein Segment berechnet wird. Die Beendigung eines Segmentes würde in jedem Fall eine Ableitung der Pain Score auslösen und einen \glqq erzwungenen Aktualisierungszeitpunkt\grqq{} darstellen. Die folgenden Möglichkeiten zur Festlegung von $t_{act}$ sind denkbar:
 
 \begin{itemize}
 \item $t_{act}$ als globaler, nicht veränderbarer Wert. Da in der Literatur keine Vorschlag diesbezüglich gefunden werden konnte, müsste ein sinnvoller Wert in Absprache mit medizinischen Fachkräften eruiert werden. 
 \item Man überlässt der medizinischen Fachkraft, die das System überwacht, die Festlegung des Aktualisierungsintervalls. So kann die Person selber bestimmen, wie häufig sie eine Aktualisierung der Pain Score wünscht.
 \item Die feste Bindung des Aktualisierungsintervalls an die verwendete Pain Scale. Die CRIES-Scale ist beispielsweise für das post-operative Monitoring gedacht und benötigt somit möglicherweise weniger häufige Aktualisierungen als der DAN, welcher zur Schmerzdiagnostik während einer Operation eingesetzt werden kann (siehe Tabelle \ref{tab:painscores}). Da die Pain Scales nicht für die kontinuierliche Schmerzdiagnostik ausgelegt sind, lässt sich aus den für einige Pain Scales eventuell vorgeschriebenen Beobachtungsintervallen kein Aktualisierungsintevall für ein kontinuierliches System argumentieren.
 \end{itemize}
 
 Wenn $t_{act}$ als zeitlicher Wert definiert wird, kann es passieren, dass eine Aktualisierung in einem offenen Segment durchgeführt wird, während gerade eine neue Cry-Unit markiert wird und noch nicht abgeschlossen wurde. Da die Funktion $PS_{Scale}: cs \mapsto \mathbb{N}$ nur für Cry-Segmente definiert wurde, die vollständige Cry-Units enthalten, wird diese \glqq halbe Cry-Unit\grqq{} nicht mit zur Ableitung der Pain Score verwendet. Der Hintergrund für diese Entscheidung ist, dass bestimmte Funktionen zum Ableiten der Features für das Segment ansonsten fehlerhafte Ergebnisse liefern können. Die Funktion $PS$ wird folglich auf das \emph{Subsegment} $cs_{sub}$ angewandt, welches alle Cry-Units des möglicherweise noch offenen Segmentes $cs$ beinhaltet, die zum Aktualisierungszeitpunkt $t$ vollständig begonnen und beendet wurden. Der Endzeitpunkt des Subsegmentes wird, wie bei herkömmlichen Segmenten, auf den Endzeitpunkt der letzten vollständigen Cry-Unit im Subsegment gelegt.
  
 \subsubsection{Beobachtungszeitraum}

Es gibt Eigenschaften, die sich implizit auf den gesamten Zeitraum \emph{Beginn des Segmentes} $start(cs)$ bis \emph{Aktualisierungszeitpunkt} $t$ beziehen, wie beispielsweise die \emph{Zeitliche Länge des Segmentes} nach Formel \ref{eq:segment_length}. Dieser Zeitraum ist gleichzeitig der längst mögliche Zeitraum innerhalb eines Segmentes, der für die Ableitung der Pain Score mit einbezogen werden kann. Es ist jedoch auch möglich, einen kürzere Beobachtungszeitraum $t_{obs}$ zu wählen. Dies hat zur Folge, dass bei der Ableitung die ersten Cry-Units des Segmentes ausgelassen werden, die außerhalb des Beobachtungszeitraums liegen. So können zeitliche Veränderungen der Pain-Score innerhalb eines Segmentes detaillierter dargestellt werden. Es sind wiederum verschiedene Varianten zur Festlegung von $t_{obs}$ denkbar:
\begin{itemize}
\item Festlegung eines globalen oder eines von der medizinischen Fachkraft frei wählbaren Wertes, so wie bei dem Aktualisierungsintervall $t_{act}$.
\item Die feste Bindung des Aktualisierungsintervalls an die verwendete Pain Scale. Einige Pain Scale empfehlen bestimmte Beobachtungszeiträume. So wird beispielsweise bei der NIPS-Scale ein Beobachtungszeitraum von einer Minute empfohlen (Siehe Kapitel \ref{sec:foundations_cryingMeta}). Es müsst wiederum in Zusammenarbeit mit medizinischen Fachkräften eruiert werden, ob diese, für die manuelle Schmerzdiagnostik vorgesehenen Werte auch für ein automatisiertes System Sinn machen.
\item Eine weitere Variante ist, $t_{obs}$ an den Wert von $t_{act}$ zu binden. Fall $t_{obs}$ frei festlegbar sein soll, muss das Personal nicht zwei Werte festlegen. Ein Verhältnis von $t_{obs} = k \cdot t_{act}$ würde mit $k=1$ nicht-überlappende Beobachtungszeiträume und  mit $k=2$ überlappende Beobachtungszeiträume erzeugen.
\end{itemize}

Der Beobachtungszeitraum $t_{obs}$ schränkt somit die Länge des Subsegmentes $cs_{sub}$ weiter ein, und zwar in diesem Fall bezüglich der Startzeitpunktes. Der Zeitraum innerhalb des Segmentes $cs$, der zur Bildung von $cs_{sub}$ genutzt wird, ist der Zeitraum \emph{Aktualisierungszeitpunkt} $t - t_{obs}$ bis $t$. Es werden nur solche Cry-Units von $cs$ in $cs_{sub}$ übernommen, die innerhalb dieses Zeitraumes vollständig begonnen und beendet werden konnten. Der Anfangszeitpunkt des Subsegments ist somit der Anfangszeitpunkt der ersten vollständigen Cry-Unit innerhalb  Beobachtungszeitraumes, der Endzeitpunkt des Subsegmentes entspricht dem Ende der zum Aktualisierungszeitpunkt zuletzt vollständig beendeten Cry-Unit.

\vspace{5mm}

\textbf{Beispiel} \noindent\rule{0.83\linewidth}{0.3pt}\\

Die in diesem Kapitel vorgestellten Methoden zur Ableitung von Pain Scores werden anhand eines Beispiels verdeutlicht. Tabelle \ref{tab:fiction_scale} definiert eine fiktive Pain Scale. Es werden die für Pain Scales typischen, subjektiv behafteten Worte zum Scoring verwendet.

\begin{table}[h]
\centering
\caption{Fiktive Pain Scale}
\label{tab:fiction_scale}
\begin{tabular}{@{}llll@{}}
\toprule
              & 0 Punkte    & 1 Punkt         & 2 Punkte       \\ \midrule
Fiction Scale & kein oder sehr wenig Weinen & normales Weinen & starkes Weinen \\ \bottomrule
\end{tabular}
\end{table}

Mit Hilfe der in Kapitel \ref{sec:deduction} beschriebenen Strategien wurde die Funktion $PS_{Fiction}: CS \mapsto \{0,1,2\}$ ermittelt, definiert in Gleichung \ref{eq:ps_fiction}. Sie erlaubt die Ableitung des Schmerz Score für eine Cry-Segment mit Hilfe objektiv messbarer Features.

\begin{equation}
PS_{Fiction}(cs) = \begin{cases}
 0 \quad ,  \text{wenn } mean_{cu}(cs) < \SI{0.3}{\second} \\
 1 \quad ,  \text{wenn } mean_{cu}(cs) < \SI{1}{\second} \\
 2 \quad ,  \text{wenn } mean_{cu}(cs) \geq \SI{1}{\second}
 \end{cases}	
 \label{eq:ps_fiction}
\end{equation}

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{bilder/regression_score_example04.png}
	\caption{Beispiel für die Ableitung von Pain Scores für ein Signal nach einer fiktiven Pain Scale ohne Beobachtungszeitraum oder Aktualisierungsintervall}
	\label{img:regression_score_example02}
\end{figure}


Abbildung \ref{img:regression_score_example01} zeigt ein Beispielsignal, für das Pain Scores nach dieser Pain Scale abgeleitet werden. In dem Signal werden die stimmhaften Signalbereiche schwarz und das Hintergrundrauschen grau dargestellt. Es sind insgesamt 10 Cry-Units zu erkennen. Die ersten fünf Cry-Units haben jeweils eine Länge von \SI{2.25}{\second}, die letzten fünf Cry-Units eine jeweilige Länge von \SI{0.75}{\second}. Das Signal wurde nach der in Kapitel \ref{sec:segmenting} beschriebenen Methode segmentiert mit $t_s = \SI{5}{\second}$ und so alle 10 Cry-Units zu einem Segment zusammengefasst. Das Segment erstreckt sich von Sekunde $10$ bis Sekunde $37.5$. Für das Segment wurde eine durchschnittliche Länge der Cry-Units von $mean_{cu}(cs) = \SI{1.5}{\second}$ gemessen und dem zufolge eine Pain Score von 2 abgeleitet. In diesem Fall wurde ohne Beobachtungs- und Aktualisierungsintervall gearbeitet. Wäre die Analyse also kontinuierlich vorgenommen worden, so wäre nach Feststellung der ersten Cry-Unit das Segment eröffnet, nach Überschreitung der maximal zulässigen Stille von $t_s = \SI{5}{\second}$ nach der 10. Cry-Unit das Segment geschlossen, und daraufhin $PS_{Fiction}(cs) = 2$ berechnet worden.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{bilder/regression_score_example05.png}
	\caption{Beispiel für die Ableitung von Pain Scores für ein Signal nach einer fiktiven Pain Scale mit $t_{act} = \SI{7.5}{\second}$ und $t_{obs} = \SI{15}{\second}$}
	\label{img:regression_score_example02}
\end{figure}

Abbildung \ref{img:regression_score_example03} zeigt die Ableitung der Schmerz Scores, wenn zusätzlich ein Aktualisierungsintervall von \SI{7.5}{\second} und ein Beobachtungszeitraum von \SI{15}{\second} gewählt wird. Nach dem das Segment durch die Cry-Unit an Sekunde 10 eröffnet wurde, werden Aktualisierungen zu den Zeitpunkten $t = \SI{17.5}{\second}, \SI{25}{\second}, \SI{32.5}{\second}$ und \SI{40}{\second} durchgeführt, verdeutlicht durch die kleinen, roten Pfeile in der Abbildung. Wie zu sehen ist, wird bei jeder Aktualisierung innerhalb des Beobachtungszeitraumes ein Subsegment gebildet, für das Subsegment die Features errechnet und die Pain Score abgeleitet. Der Anfangszeitpunkt jedes Subsegmentes ist der Anfang der erste Cry-Unit innerhalb des jeweiligen Beobachtungszeitraums, und das Ende des Subsegmentes das Ende letzten Cry-Unit im jeweiligen Beobachtungszeitraum. Beispielsweise erstreckt sich das bei der 3. Aktualisierung der Beobachtungszeitraum von $17.5 - \SI{32.5}{\second}$, das Subsegment jedoch von $19 - \SI{32}{\second}$ aufgrund der Lage der Cry-Units. Durch die Verwendung des Beobachtungs- und Aktualisierungsintervalls wird erkennbar, dass in diesem Beispiel der Schmerzgrad innerhalb des Segmentes nach hinten hin abnimmt.


